#!/bin/sh
# строка выше служит для указания интерпретатора который должен использоваться для интерпритирования скрипта.
# что надо знать
# 1. должно быть первой строкой; читается оболочкой пользователя
# 2. /bin/sh - это буквально путь до бинарного файла интерпретатора
# 3. shell, интерпретатор - разные названия одного и того же
# 4. /bin/sh - вызывает дефольный интерпретатор
# 5. /bin/bash/ /bin/zsh /bin/csh - разные варианты интерпретаторов. с разным синтаксисом


# Присваивание без пробелов
rows=$1
# $1, $2 - это переменные переданные скрипту
cols=$2

n_row=1
n_col=1

# ! Все пробелы в следуюшей строке обязательны:
while [ $n_row -le $rows ]
# -le означает "is less than or equal to"
#  Другие операторы https://tldp.org/LDP/abs/html/comparison-ops.html
do
  n_col=1
  # Здесь надо ставить точку запятую что бы оператор do можно было разместить на одной строке с while
  while [ $n_col -le $cols ]; do
    # $(...) - синтаксис операций  над переменными
    nombre=$((n_row*n_col))
    # Чиобы выроянять колонки по ширине надо посчитать максимальную щирину колонки
    # Сейчас column_width число - произведение номера колонки на количество строк
    column_width=$(($n_col * $rows))
    
    # $(#variable) - возвращает количество символов в строке. Но строка это переведеное в строку число - то есть получаем количество цифр в числе
    column_width=${#column_width}

    # оператор printf печатает строку с переданными параметрами 
    nombre=$(printf "%*d" $column_width $nombre)
    # если требуется вывести число с лидирующими нулями у цифр
    # nombre=$(printf "%0*d" $column_width $nombre)

    # Двойные ковычки используются для интерполяции указанных переменных
    # Пробел в конце строки нужен для отступов между колонками
    echo -n "$nombre "
    # флаг -n  выводит строку без символа переноса строки 

    
    n_col=$((n_col+1))  
    
    
  done
  # Теперь требуется сделать перенос строки поэтому печатаем пустую строку
  echo ""
  n_row=$((n_row+1))
done
